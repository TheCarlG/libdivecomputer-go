// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 01 Jun 2018 23:25:14 CEST.
// By https://git.io/c-for-go. DO NOT EDIT.

package core

/*
#cgo pkg-config: libdivecomputer
#include <stddef.h>
#include "libdivecomputer/parser.h"
#include "libdivecomputer/device.h"
#include "libdivecomputer/version.h"
#include "libdivecomputer/context.h"
#include "libdivecomputer/descriptor.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocSalinityMemory allocates memory for type C.dc_salinity_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSalinityMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSalinityValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSalinityValue = unsafe.Sizeof([1]C.dc_salinity_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Salinity) Ref() *C.dc_salinity_t {
	if x == nil {
		return nil
	}
	return x.refc9529d52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Salinity) Free() {
	if x != nil && x.allocsc9529d52 != nil {
		x.allocsc9529d52.(*cgoAllocMap).Free()
		x.refc9529d52 = nil
	}
}

// NewSalinityRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSalinityRef(ref unsafe.Pointer) *Salinity {
	if ref == nil {
		return nil
	}
	obj := new(Salinity)
	obj.refc9529d52 = (*C.dc_salinity_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Salinity) PassRef() (*C.dc_salinity_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9529d52 != nil {
		return x.refc9529d52, nil
	}
	memc9529d52 := allocSalinityMemory(1)
	refc9529d52 := (*C.dc_salinity_t)(memc9529d52)
	allocsc9529d52 := new(cgoAllocMap)
	allocsc9529d52.Add(memc9529d52)

	var c_type_allocs *cgoAllocMap
	refc9529d52._type, c_type_allocs = (C.dc_water_t)(x.Type), cgoAllocsUnknown
	allocsc9529d52.Borrow(c_type_allocs)

	var cdensity_allocs *cgoAllocMap
	refc9529d52.density, cdensity_allocs = (C.double)(x.Density), cgoAllocsUnknown
	allocsc9529d52.Borrow(cdensity_allocs)

	x.refc9529d52 = refc9529d52
	x.allocsc9529d52 = allocsc9529d52
	return refc9529d52, allocsc9529d52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Salinity) PassValue() (C.dc_salinity_t, *cgoAllocMap) {
	if x.refc9529d52 != nil {
		return *x.refc9529d52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Salinity) Deref() {
	if x.refc9529d52 == nil {
		return
	}
	x.Type = (Water)(x.refc9529d52._type)
	x.Density = (float64)(x.refc9529d52.density)
}

// allocGasmixMemory allocates memory for type C.dc_gasmix_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGasmixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGasmixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGasmixValue = unsafe.Sizeof([1]C.dc_gasmix_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Gasmix) Ref() *C.dc_gasmix_t {
	if x == nil {
		return nil
	}
	return x.ref71cd323d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Gasmix) Free() {
	if x != nil && x.allocs71cd323d != nil {
		x.allocs71cd323d.(*cgoAllocMap).Free()
		x.ref71cd323d = nil
	}
}

// NewGasmixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGasmixRef(ref unsafe.Pointer) *Gasmix {
	if ref == nil {
		return nil
	}
	obj := new(Gasmix)
	obj.ref71cd323d = (*C.dc_gasmix_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Gasmix) PassRef() (*C.dc_gasmix_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref71cd323d != nil {
		return x.ref71cd323d, nil
	}
	mem71cd323d := allocGasmixMemory(1)
	ref71cd323d := (*C.dc_gasmix_t)(mem71cd323d)
	allocs71cd323d := new(cgoAllocMap)
	allocs71cd323d.Add(mem71cd323d)

	var chelium_allocs *cgoAllocMap
	ref71cd323d.helium, chelium_allocs = (C.double)(x.Helium), cgoAllocsUnknown
	allocs71cd323d.Borrow(chelium_allocs)

	var coxygen_allocs *cgoAllocMap
	ref71cd323d.oxygen, coxygen_allocs = (C.double)(x.Oxygen), cgoAllocsUnknown
	allocs71cd323d.Borrow(coxygen_allocs)

	var cnitrogen_allocs *cgoAllocMap
	ref71cd323d.nitrogen, cnitrogen_allocs = (C.double)(x.Nitrogen), cgoAllocsUnknown
	allocs71cd323d.Borrow(cnitrogen_allocs)

	x.ref71cd323d = ref71cd323d
	x.allocs71cd323d = allocs71cd323d
	return ref71cd323d, allocs71cd323d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Gasmix) PassValue() (C.dc_gasmix_t, *cgoAllocMap) {
	if x.ref71cd323d != nil {
		return *x.ref71cd323d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Gasmix) Deref() {
	if x.ref71cd323d == nil {
		return
	}
	x.Helium = (float64)(x.ref71cd323d.helium)
	x.Oxygen = (float64)(x.ref71cd323d.oxygen)
	x.Nitrogen = (float64)(x.ref71cd323d.nitrogen)
}

// allocTankMemory allocates memory for type C.dc_tank_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTankMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTankValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTankValue = unsafe.Sizeof([1]C.dc_tank_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tank) Ref() *C.dc_tank_t {
	if x == nil {
		return nil
	}
	return x.refadaebb65
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tank) Free() {
	if x != nil && x.allocsadaebb65 != nil {
		x.allocsadaebb65.(*cgoAllocMap).Free()
		x.refadaebb65 = nil
	}
}

// NewTankRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTankRef(ref unsafe.Pointer) *Tank {
	if ref == nil {
		return nil
	}
	obj := new(Tank)
	obj.refadaebb65 = (*C.dc_tank_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tank) PassRef() (*C.dc_tank_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refadaebb65 != nil {
		return x.refadaebb65, nil
	}
	memadaebb65 := allocTankMemory(1)
	refadaebb65 := (*C.dc_tank_t)(memadaebb65)
	allocsadaebb65 := new(cgoAllocMap)
	allocsadaebb65.Add(memadaebb65)

	var cgasmix_allocs *cgoAllocMap
	refadaebb65.gasmix, cgasmix_allocs = (C.uint)(x.Gasmix), cgoAllocsUnknown
	allocsadaebb65.Borrow(cgasmix_allocs)

	var c_type_allocs *cgoAllocMap
	refadaebb65._type, c_type_allocs = (C.dc_tankvolume_t)(x.Type), cgoAllocsUnknown
	allocsadaebb65.Borrow(c_type_allocs)

	var cvolume_allocs *cgoAllocMap
	refadaebb65.volume, cvolume_allocs = (C.double)(x.Volume), cgoAllocsUnknown
	allocsadaebb65.Borrow(cvolume_allocs)

	var cworkpressure_allocs *cgoAllocMap
	refadaebb65.workpressure, cworkpressure_allocs = (C.double)(x.Workpressure), cgoAllocsUnknown
	allocsadaebb65.Borrow(cworkpressure_allocs)

	var cbeginpressure_allocs *cgoAllocMap
	refadaebb65.beginpressure, cbeginpressure_allocs = (C.double)(x.Beginpressure), cgoAllocsUnknown
	allocsadaebb65.Borrow(cbeginpressure_allocs)

	var cendpressure_allocs *cgoAllocMap
	refadaebb65.endpressure, cendpressure_allocs = (C.double)(x.Endpressure), cgoAllocsUnknown
	allocsadaebb65.Borrow(cendpressure_allocs)

	x.refadaebb65 = refadaebb65
	x.allocsadaebb65 = allocsadaebb65
	return refadaebb65, allocsadaebb65

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tank) PassValue() (C.dc_tank_t, *cgoAllocMap) {
	if x.refadaebb65 != nil {
		return *x.refadaebb65, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tank) Deref() {
	if x.refadaebb65 == nil {
		return
	}
	x.Gasmix = (uint32)(x.refadaebb65.gasmix)
	x.Type = (Tankvolume)(x.refadaebb65._type)
	x.Volume = (float64)(x.refadaebb65.volume)
	x.Workpressure = (float64)(x.refadaebb65.workpressure)
	x.Beginpressure = (float64)(x.refadaebb65.beginpressure)
	x.Endpressure = (float64)(x.refadaebb65.endpressure)
}

// Ref returns a reference to C object as it is.
func (x *Parser) Ref() *C.dc_parser_t {
	if x == nil {
		return nil
	}
	return (*C.dc_parser_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Parser) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewParserRef converts the C object reference into a raw struct reference without wrapping.
func NewParserRef(ref unsafe.Pointer) *Parser {
	return (*Parser)(ref)
}

// NewParser allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewParser() *Parser {
	return (*Parser)(allocParserMemory(1))
}

// allocParserMemory allocates memory for type C.dc_parser_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocParserMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfParserValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfParserValue = unsafe.Sizeof([1]C.dc_parser_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Parser) PassRef() *C.dc_parser_t {
	if x == nil {
		x = (*Parser)(allocParserMemory(1))
	}
	return (*C.dc_parser_t)(unsafe.Pointer(x))
}

func (x SampleCallback) PassRef() (ref *C.dc_sample_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if sampleCallbackA3BF8997Func == nil {
		sampleCallbackA3BF8997Func = x
	}
	return (*C.dc_sample_callback_t)(C.dc_sample_callback_t_a3bf8997), nil
}

func (x SampleCallback) PassValue() (ref C.dc_sample_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if sampleCallbackA3BF8997Func == nil {
		sampleCallbackA3BF8997Func = x
	}
	return (C.dc_sample_callback_t)(C.dc_sample_callback_t_a3bf8997), nil
}

func NewSampleCallbackRef(ref unsafe.Pointer) *SampleCallback {
	return (*SampleCallback)(ref)
}

//export sampleCallbackA3BF8997
func sampleCallbackA3BF8997(ckind C.dc_sample_type_t, cvalue C.dc_sample_value_t, cuserdata unsafe.Pointer) {
	if sampleCallbackA3BF8997Func != nil {
		kinda3bf8997 := (SampleType)(ckind)
		valuea3bf8997 := *(*SampleValue)(unsafe.Pointer(&cvalue))
		userdataa3bf8997 := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		sampleCallbackA3BF8997Func(kinda3bf8997, valuea3bf8997, userdataa3bf8997)
		return
	}
	panic("callback func has not been set (race?)")
}

var sampleCallbackA3BF8997Func SampleCallback

// Ref returns a reference to C object as it is.
func (x *Context) Ref() *C.dc_context_t {
	if x == nil {
		return nil
	}
	return (*C.dc_context_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Context) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewContextRef converts the C object reference into a raw struct reference without wrapping.
func NewContextRef(ref unsafe.Pointer) *Context {
	return (*Context)(ref)
}

// NewContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewContext() *Context {
	return (*Context)(allocContextMemory(1))
}

// allocContextMemory allocates memory for type C.dc_context_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfContextValue = unsafe.Sizeof([1]C.dc_context_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Context) PassRef() *C.dc_context_t {
	if x == nil {
		x = (*Context)(allocContextMemory(1))
	}
	return (*C.dc_context_t)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x Logfunc) PassRef() (ref *C.dc_logfunc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logfunc38998C27Func == nil {
		logfunc38998C27Func = x
	}
	return (*C.dc_logfunc_t)(C.dc_logfunc_t_38998c27), nil
}

func (x Logfunc) PassValue() (ref C.dc_logfunc_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logfunc38998C27Func == nil {
		logfunc38998C27Func = x
	}
	return (C.dc_logfunc_t)(C.dc_logfunc_t_38998c27), nil
}

func NewLogfuncRef(ref unsafe.Pointer) *Logfunc {
	return (*Logfunc)(ref)
}

//export logfunc38998C27
func logfunc38998C27(ccontext *C.dc_context_t, cloglevel C.dc_loglevel_t, cfile *C.char, cline C.uint, cfunction *C.char, cmessage *C.char, cuserdata unsafe.Pointer) {
	if logfunc38998C27Func != nil {
		context38998c27 := (*Context)(unsafe.Pointer(ccontext))
		loglevel38998c27 := (Loglevel)(cloglevel)
		file38998c27 := packPCharString(cfile)
		line38998c27 := (uint32)(cline)
		function38998c27 := packPCharString(cfunction)
		message38998c27 := packPCharString(cmessage)
		userdata38998c27 := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		logfunc38998C27Func(context38998c27, loglevel38998c27, file38998c27, line38998c27, function38998c27, message38998c27, userdata38998c27)
		return
	}
	panic("callback func has not been set (race?)")
}

var logfunc38998C27Func Logfunc

// Ref returns a reference to C object as it is.
func (x *Descriptor) Ref() *C.dc_descriptor_t {
	if x == nil {
		return nil
	}
	return (*C.dc_descriptor_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Descriptor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDescriptorRef converts the C object reference into a raw struct reference without wrapping.
func NewDescriptorRef(ref unsafe.Pointer) *Descriptor {
	return (*Descriptor)(ref)
}

// NewDescriptor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDescriptor() *Descriptor {
	return (*Descriptor)(allocDescriptorMemory(1))
}

// allocDescriptorMemory allocates memory for type C.dc_descriptor_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorValue = unsafe.Sizeof([1]C.dc_descriptor_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Descriptor) PassRef() *C.dc_descriptor_t {
	if x == nil {
		x = (*Descriptor)(allocDescriptorMemory(1))
	}
	return (*C.dc_descriptor_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Iterator) Ref() *C.dc_iterator_t {
	if x == nil {
		return nil
	}
	return (*C.dc_iterator_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Iterator) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIteratorRef converts the C object reference into a raw struct reference without wrapping.
func NewIteratorRef(ref unsafe.Pointer) *Iterator {
	return (*Iterator)(ref)
}

// NewIterator allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIterator() *Iterator {
	return (*Iterator)(allocIteratorMemory(1))
}

// allocIteratorMemory allocates memory for type C.dc_iterator_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIteratorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIteratorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIteratorValue = unsafe.Sizeof([1]C.dc_iterator_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Iterator) PassRef() *C.dc_iterator_t {
	if x == nil {
		x = (*Iterator)(allocIteratorMemory(1))
	}
	return (*C.dc_iterator_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Device) Ref() *C.dc_device_t {
	if x == nil {
		return nil
	}
	return (*C.dc_device_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Device) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceRef(ref unsafe.Pointer) *Device {
	return (*Device)(ref)
}

// NewDevice allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDevice() *Device {
	return (*Device)(allocDeviceMemory(1))
}

// allocDeviceMemory allocates memory for type C.dc_device_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceValue = unsafe.Sizeof([1]C.dc_device_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Device) PassRef() *C.dc_device_t {
	if x == nil {
		x = (*Device)(allocDeviceMemory(1))
	}
	return (*C.dc_device_t)(unsafe.Pointer(x))
}

// allocEventProgressMemory allocates memory for type C.dc_event_progress_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventProgressMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventProgressValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventProgressValue = unsafe.Sizeof([1]C.dc_event_progress_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventProgress) Ref() *C.dc_event_progress_t {
	if x == nil {
		return nil
	}
	return x.refb363a956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventProgress) Free() {
	if x != nil && x.allocsb363a956 != nil {
		x.allocsb363a956.(*cgoAllocMap).Free()
		x.refb363a956 = nil
	}
}

// NewEventProgressRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventProgressRef(ref unsafe.Pointer) *EventProgress {
	if ref == nil {
		return nil
	}
	obj := new(EventProgress)
	obj.refb363a956 = (*C.dc_event_progress_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventProgress) PassRef() (*C.dc_event_progress_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb363a956 != nil {
		return x.refb363a956, nil
	}
	memb363a956 := allocEventProgressMemory(1)
	refb363a956 := (*C.dc_event_progress_t)(memb363a956)
	allocsb363a956 := new(cgoAllocMap)
	allocsb363a956.Add(memb363a956)

	var ccurrent_allocs *cgoAllocMap
	refb363a956.current, ccurrent_allocs = (C.uint)(x.Current), cgoAllocsUnknown
	allocsb363a956.Borrow(ccurrent_allocs)

	var cmaximum_allocs *cgoAllocMap
	refb363a956.maximum, cmaximum_allocs = (C.uint)(x.Maximum), cgoAllocsUnknown
	allocsb363a956.Borrow(cmaximum_allocs)

	x.refb363a956 = refb363a956
	x.allocsb363a956 = allocsb363a956
	return refb363a956, allocsb363a956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventProgress) PassValue() (C.dc_event_progress_t, *cgoAllocMap) {
	if x.refb363a956 != nil {
		return *x.refb363a956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventProgress) Deref() {
	if x.refb363a956 == nil {
		return
	}
	x.Current = (uint32)(x.refb363a956.current)
	x.Maximum = (uint32)(x.refb363a956.maximum)
}

// allocEventDevinfoMemory allocates memory for type C.dc_event_devinfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventDevinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventDevinfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventDevinfoValue = unsafe.Sizeof([1]C.dc_event_devinfo_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventDevinfo) Ref() *C.dc_event_devinfo_t {
	if x == nil {
		return nil
	}
	return x.ref72b3861f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventDevinfo) Free() {
	if x != nil && x.allocs72b3861f != nil {
		x.allocs72b3861f.(*cgoAllocMap).Free()
		x.ref72b3861f = nil
	}
}

// NewEventDevinfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventDevinfoRef(ref unsafe.Pointer) *EventDevinfo {
	if ref == nil {
		return nil
	}
	obj := new(EventDevinfo)
	obj.ref72b3861f = (*C.dc_event_devinfo_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventDevinfo) PassRef() (*C.dc_event_devinfo_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref72b3861f != nil {
		return x.ref72b3861f, nil
	}
	mem72b3861f := allocEventDevinfoMemory(1)
	ref72b3861f := (*C.dc_event_devinfo_t)(mem72b3861f)
	allocs72b3861f := new(cgoAllocMap)
	allocs72b3861f.Add(mem72b3861f)

	var cmodel_allocs *cgoAllocMap
	ref72b3861f.model, cmodel_allocs = (C.uint)(x.Model), cgoAllocsUnknown
	allocs72b3861f.Borrow(cmodel_allocs)

	var cfirmware_allocs *cgoAllocMap
	ref72b3861f.firmware, cfirmware_allocs = (C.uint)(x.Firmware), cgoAllocsUnknown
	allocs72b3861f.Borrow(cfirmware_allocs)

	var cserial_allocs *cgoAllocMap
	ref72b3861f.serial, cserial_allocs = (C.uint)(x.Serial), cgoAllocsUnknown
	allocs72b3861f.Borrow(cserial_allocs)

	x.ref72b3861f = ref72b3861f
	x.allocs72b3861f = allocs72b3861f
	return ref72b3861f, allocs72b3861f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventDevinfo) PassValue() (C.dc_event_devinfo_t, *cgoAllocMap) {
	if x.ref72b3861f != nil {
		return *x.ref72b3861f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventDevinfo) Deref() {
	if x.ref72b3861f == nil {
		return
	}
	x.Model = (uint32)(x.ref72b3861f.model)
	x.Firmware = (uint32)(x.ref72b3861f.firmware)
	x.Serial = (uint32)(x.ref72b3861f.serial)
}

// allocEventClockMemory allocates memory for type C.dc_event_clock_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventClockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventClockValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventClockValue = unsafe.Sizeof([1]C.dc_event_clock_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventClock) Ref() *C.dc_event_clock_t {
	if x == nil {
		return nil
	}
	return x.refed081ba0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventClock) Free() {
	if x != nil && x.allocsed081ba0 != nil {
		x.allocsed081ba0.(*cgoAllocMap).Free()
		x.refed081ba0 = nil
	}
}

// NewEventClockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventClockRef(ref unsafe.Pointer) *EventClock {
	if ref == nil {
		return nil
	}
	obj := new(EventClock)
	obj.refed081ba0 = (*C.dc_event_clock_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventClock) PassRef() (*C.dc_event_clock_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed081ba0 != nil {
		return x.refed081ba0, nil
	}
	memed081ba0 := allocEventClockMemory(1)
	refed081ba0 := (*C.dc_event_clock_t)(memed081ba0)
	allocsed081ba0 := new(cgoAllocMap)
	allocsed081ba0.Add(memed081ba0)

	var cdevtime_allocs *cgoAllocMap
	refed081ba0.devtime, cdevtime_allocs = (C.uint)(x.Devtime), cgoAllocsUnknown
	allocsed081ba0.Borrow(cdevtime_allocs)

	var csystime_allocs *cgoAllocMap
	refed081ba0.systime, csystime_allocs = (C.dc_ticks_t)(x.Systime), cgoAllocsUnknown
	allocsed081ba0.Borrow(csystime_allocs)

	x.refed081ba0 = refed081ba0
	x.allocsed081ba0 = allocsed081ba0
	return refed081ba0, allocsed081ba0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventClock) PassValue() (C.dc_event_clock_t, *cgoAllocMap) {
	if x.refed081ba0 != nil {
		return *x.refed081ba0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventClock) Deref() {
	if x.refed081ba0 == nil {
		return
	}
	x.Devtime = (uint32)(x.refed081ba0.devtime)
	x.Systime = (Ticks)(x.refed081ba0.systime)
}

// allocEventVendorMemory allocates memory for type C.dc_event_vendor_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventVendorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventVendorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventVendorValue = unsafe.Sizeof([1]C.dc_event_vendor_t{})

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(h.Data), cgoAllocsUnknown
}

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventVendor) Ref() *C.dc_event_vendor_t {
	if x == nil {
		return nil
	}
	return x.ref42693bff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventVendor) Free() {
	if x != nil && x.allocs42693bff != nil {
		x.allocs42693bff.(*cgoAllocMap).Free()
		x.ref42693bff = nil
	}
}

// NewEventVendorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventVendorRef(ref unsafe.Pointer) *EventVendor {
	if ref == nil {
		return nil
	}
	obj := new(EventVendor)
	obj.ref42693bff = (*C.dc_event_vendor_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventVendor) PassRef() (*C.dc_event_vendor_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42693bff != nil {
		return x.ref42693bff, nil
	}
	mem42693bff := allocEventVendorMemory(1)
	ref42693bff := (*C.dc_event_vendor_t)(mem42693bff)
	allocs42693bff := new(cgoAllocMap)
	allocs42693bff.Add(mem42693bff)

	var cdata_allocs *cgoAllocMap
	ref42693bff.data, cdata_allocs = unpackPUcharString(x.Data)
	allocs42693bff.Borrow(cdata_allocs)

	var csize_allocs *cgoAllocMap
	ref42693bff.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs42693bff.Borrow(csize_allocs)

	x.ref42693bff = ref42693bff
	x.allocs42693bff = allocs42693bff
	return ref42693bff, allocs42693bff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventVendor) PassValue() (C.dc_event_vendor_t, *cgoAllocMap) {
	if x.ref42693bff != nil {
		return *x.ref42693bff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventVendor) Deref() {
	if x.ref42693bff == nil {
		return
	}
	x.Data = packPUcharString(x.ref42693bff.data)
	x.Size = (uint32)(x.ref42693bff.size)
}

func (x CancelCallback) PassRef() (ref *C.dc_cancel_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cancelCallbackA57C535DFunc == nil {
		cancelCallbackA57C535DFunc = x
	}
	return (*C.dc_cancel_callback_t)(C.dc_cancel_callback_t_a57c535d), nil
}

func (x CancelCallback) PassValue() (ref C.dc_cancel_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cancelCallbackA57C535DFunc == nil {
		cancelCallbackA57C535DFunc = x
	}
	return (C.dc_cancel_callback_t)(C.dc_cancel_callback_t_a57c535d), nil
}

func NewCancelCallbackRef(ref unsafe.Pointer) *CancelCallback {
	return (*CancelCallback)(ref)
}

//export cancelCallbackA57C535D
func cancelCallbackA57C535D(cuserdata unsafe.Pointer) C.int {
	if cancelCallbackA57C535DFunc != nil {
		userdataa57c535d := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		reta57c535d := cancelCallbackA57C535DFunc(userdataa57c535d)
		ret, _ := (C.int)(reta57c535d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var cancelCallbackA57C535DFunc CancelCallback

func (x EventCallback) PassRef() (ref *C.dc_event_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if eventCallbackD245BF1CFunc == nil {
		eventCallbackD245BF1CFunc = x
	}
	return (*C.dc_event_callback_t)(C.dc_event_callback_t_d245bf1c), nil
}

func (x EventCallback) PassValue() (ref C.dc_event_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if eventCallbackD245BF1CFunc == nil {
		eventCallbackD245BF1CFunc = x
	}
	return (C.dc_event_callback_t)(C.dc_event_callback_t_d245bf1c), nil
}

func NewEventCallbackRef(ref unsafe.Pointer) *EventCallback {
	return (*EventCallback)(ref)
}

//export eventCallbackD245BF1C
func eventCallbackD245BF1C(cdevice *C.dc_device_t, cevent C.dc_event_type_t, cdata unsafe.Pointer, cuserdata unsafe.Pointer) {
	if eventCallbackD245BF1CFunc != nil {
		deviced245bf1c := (*Device)(unsafe.Pointer(cdevice))
		eventd245bf1c := (EventType)(cevent)
		datad245bf1c := (unsafe.Pointer)(unsafe.Pointer(cdata))
		userdatad245bf1c := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		eventCallbackD245BF1CFunc(deviced245bf1c, eventd245bf1c, datad245bf1c, userdatad245bf1c)
		return
	}
	panic("callback func has not been set (race?)")
}

var eventCallbackD245BF1CFunc EventCallback

func (x DiveCallback) PassRef() (ref *C.dc_dive_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if diveCallback1A75734AFunc == nil {
		diveCallback1A75734AFunc = x
	}
	return (*C.dc_dive_callback_t)(C.dc_dive_callback_t_1a75734a), nil
}

func (x DiveCallback) PassValue() (ref C.dc_dive_callback_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if diveCallback1A75734AFunc == nil {
		diveCallback1A75734AFunc = x
	}
	return (C.dc_dive_callback_t)(C.dc_dive_callback_t_1a75734a), nil
}

func NewDiveCallbackRef(ref unsafe.Pointer) *DiveCallback {
	return (*DiveCallback)(ref)
}

//export diveCallback1A75734A
func diveCallback1A75734A(cdata *C.uchar, csize C.uint, cfingerprint *C.uchar, cfsize C.uint, cuserdata unsafe.Pointer) C.int {
	if diveCallback1A75734AFunc != nil {
		data1a75734a := packPUcharString(cdata)
		size1a75734a := (uint32)(csize)
		fingerprint1a75734a := packPUcharString(cfingerprint)
		fsize1a75734a := (uint32)(cfsize)
		userdata1a75734a := (unsafe.Pointer)(unsafe.Pointer(cuserdata))
		ret1a75734a := diveCallback1A75734AFunc(data1a75734a, size1a75734a, fingerprint1a75734a, fsize1a75734a, userdata1a75734a)
		ret, _ := (C.int)(ret1a75734a), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var diveCallback1A75734AFunc DiveCallback

// Ref returns a reference to C object as it is.
func (x *Buffer) Ref() *C.dc_buffer_t {
	if x == nil {
		return nil
	}
	return (*C.dc_buffer_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Buffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewBufferRef(ref unsafe.Pointer) *Buffer {
	return (*Buffer)(ref)
}

// NewBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBuffer() *Buffer {
	return (*Buffer)(allocBufferMemory(1))
}

// allocBufferMemory allocates memory for type C.dc_buffer_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferValue = unsafe.Sizeof([1]C.dc_buffer_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Buffer) PassRef() *C.dc_buffer_t {
	if x == nil {
		x = (*Buffer)(allocBufferMemory(1))
	}
	return (*C.dc_buffer_t)(unsafe.Pointer(x))
}

// allocDatetimeMemory allocates memory for type C.dc_datetime_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDatetimeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDatetimeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDatetimeValue = unsafe.Sizeof([1]C.dc_datetime_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Datetime) Ref() *C.dc_datetime_t {
	if x == nil {
		return nil
	}
	return x.reffebe24d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Datetime) Free() {
	if x != nil && x.allocsfebe24d5 != nil {
		x.allocsfebe24d5.(*cgoAllocMap).Free()
		x.reffebe24d5 = nil
	}
}

// NewDatetimeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDatetimeRef(ref unsafe.Pointer) *Datetime {
	if ref == nil {
		return nil
	}
	obj := new(Datetime)
	obj.reffebe24d5 = (*C.dc_datetime_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Datetime) PassRef() (*C.dc_datetime_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffebe24d5 != nil {
		return x.reffebe24d5, nil
	}
	memfebe24d5 := allocDatetimeMemory(1)
	reffebe24d5 := (*C.dc_datetime_t)(memfebe24d5)
	allocsfebe24d5 := new(cgoAllocMap)
	allocsfebe24d5.Add(memfebe24d5)

	var cyear_allocs *cgoAllocMap
	reffebe24d5.year, cyear_allocs = (C.int)(x.Year), cgoAllocsUnknown
	allocsfebe24d5.Borrow(cyear_allocs)

	var cmonth_allocs *cgoAllocMap
	reffebe24d5.month, cmonth_allocs = (C.int)(x.Month), cgoAllocsUnknown
	allocsfebe24d5.Borrow(cmonth_allocs)

	var cday_allocs *cgoAllocMap
	reffebe24d5.day, cday_allocs = (C.int)(x.Day), cgoAllocsUnknown
	allocsfebe24d5.Borrow(cday_allocs)

	var chour_allocs *cgoAllocMap
	reffebe24d5.hour, chour_allocs = (C.int)(x.Hour), cgoAllocsUnknown
	allocsfebe24d5.Borrow(chour_allocs)

	var cminute_allocs *cgoAllocMap
	reffebe24d5.minute, cminute_allocs = (C.int)(x.Minute), cgoAllocsUnknown
	allocsfebe24d5.Borrow(cminute_allocs)

	var csecond_allocs *cgoAllocMap
	reffebe24d5.second, csecond_allocs = (C.int)(x.Second), cgoAllocsUnknown
	allocsfebe24d5.Borrow(csecond_allocs)

	var ctimezone_allocs *cgoAllocMap
	reffebe24d5.timezone, ctimezone_allocs = (C.int)(x.Timezone), cgoAllocsUnknown
	allocsfebe24d5.Borrow(ctimezone_allocs)

	x.reffebe24d5 = reffebe24d5
	x.allocsfebe24d5 = allocsfebe24d5
	return reffebe24d5, allocsfebe24d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Datetime) PassValue() (C.dc_datetime_t, *cgoAllocMap) {
	if x.reffebe24d5 != nil {
		return *x.reffebe24d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Datetime) Deref() {
	if x.reffebe24d5 == nil {
		return
	}
	x.Year = (int32)(x.reffebe24d5.year)
	x.Month = (int32)(x.reffebe24d5.month)
	x.Day = (int32)(x.reffebe24d5.day)
	x.Hour = (int32)(x.reffebe24d5.hour)
	x.Minute = (int32)(x.reffebe24d5.minute)
	x.Second = (int32)(x.reffebe24d5.second)
	x.Timezone = (int32)(x.reffebe24d5.timezone)
}

// allocVersionMemory allocates memory for type C.dc_version_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVersionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVersionValue = unsafe.Sizeof([1]C.dc_version_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Version) Ref() *C.dc_version_t {
	if x == nil {
		return nil
	}
	return x.refe33ef6f4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Version) Free() {
	if x != nil && x.allocse33ef6f4 != nil {
		x.allocse33ef6f4.(*cgoAllocMap).Free()
		x.refe33ef6f4 = nil
	}
}

// NewVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVersionRef(ref unsafe.Pointer) *Version {
	if ref == nil {
		return nil
	}
	obj := new(Version)
	obj.refe33ef6f4 = (*C.dc_version_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Version) PassRef() (*C.dc_version_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe33ef6f4 != nil {
		return x.refe33ef6f4, nil
	}
	meme33ef6f4 := allocVersionMemory(1)
	refe33ef6f4 := (*C.dc_version_t)(meme33ef6f4)
	allocse33ef6f4 := new(cgoAllocMap)
	allocse33ef6f4.Add(meme33ef6f4)

	var cmajor_allocs *cgoAllocMap
	refe33ef6f4.major, cmajor_allocs = (C.uint)(x.Major), cgoAllocsUnknown
	allocse33ef6f4.Borrow(cmajor_allocs)

	var cminor_allocs *cgoAllocMap
	refe33ef6f4.minor, cminor_allocs = (C.uint)(x.Minor), cgoAllocsUnknown
	allocse33ef6f4.Borrow(cminor_allocs)

	var cmicro_allocs *cgoAllocMap
	refe33ef6f4.micro, cmicro_allocs = (C.uint)(x.Micro), cgoAllocsUnknown
	allocse33ef6f4.Borrow(cmicro_allocs)

	x.refe33ef6f4 = refe33ef6f4
	x.allocse33ef6f4 = allocse33ef6f4
	return refe33ef6f4, allocse33ef6f4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Version) PassValue() (C.dc_version_t, *cgoAllocMap) {
	if x.refe33ef6f4 != nil {
		return *x.refe33ef6f4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Version) Deref() {
	if x.refe33ef6f4 == nil {
		return
	}
	x.Major = (uint32)(x.refe33ef6f4.major)
	x.Minor = (uint32)(x.refe33ef6f4.minor)
	x.Micro = (uint32)(x.refe33ef6f4.micro)
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSDatetime transforms a sliced Go data structure into plain C format.
func unpackArgSDatetime(x []Datetime) (unpacked *C.dc_datetime_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.dc_datetime_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDatetimeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.dc_datetime_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.dc_datetime_t)(h.Data)
	return
}

// packSDatetime reads sliced Go data structure out from plain C format.
func packSDatetime(v []Datetime, ptr0 *C.dc_datetime_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDatetimeValue]C.dc_datetime_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDatetimeRef(unsafe.Pointer(&ptr1))
	}
}
